#!/usr/bin/python
DEBUG=False
import sys
import gzip
import glob
import os
import pylab, matplotlib
import numpy as np
from optparse import OptionParser, OptionGroup, OptionValueError

import fileReader
import regionClassifier
import supportConfig

### TRYING SCIPY COMPILE WORKAROUND
#---  SCIPY cxFreeze dependency fixes
import scipy.misc
import scipy
scipy.factorial = scipy.misc.common.factorial

from scipy import factorial
import scipy.signal

#---  matplotlib cxFreeze dependency fixes
import matplotlib.backends.backend_tkagg
####################################

HGDP_BASENAME=supportConfig.createDataPath('data/hgdp/*/*chr%s.bgl.phased.gz')
MAPFILES=supportConfig.createDataPath('data/hapmap2/genetic_map_chr%s_b36.txt')
USAGE="""%prog [options] ancestralFile1 ancestralFile2 [...] admixedFile

where the ancestralFiles and admixedFiles are contain phased samples
in tab delimited format snps in rows and samples in columns.  One row
of column headers and two columns of header information (i.e. rsId and
position).  The files have to be from the same chromosome indicated by
including chr[0-9]* in the name.
"""


def winSizeBPandCM(snpLocations, winSize, chrom):
    gm=regionClassifier.geneticMap(MAPFILES%chrom)
    winStarts=[0]; winStarts.extend(snpLocations[::winSize])
    gmPos=gm.pos2gm(winStarts)
    return np.diff(winStarts), np.diff(gmPos)


def determineChromosome(fileNames):
    """Estimates the chromosome name by searching for "chr" in input
    file names.
    Arguments:
    - @fileNames:List of fileNames 
    """
    import re 
    p = re.compile('chr\d*', re.IGNORECASE)
    try:
        found=[p.search(name).group() for name in fileNames]
        if not np.all(found[0]==np.asarray(found)): raise Error
        return found[0]
    except:
        supportConfig.fail(parser, 'If no chromosome is specified then all fileNames must contain the same pattern of: chr[0-9]*')


def runSVM(fileNames, nGens, win_size, chrom, svmC=100):
    """Deconvolves ancestry in last file based on ancestral
    populations in first files. TODO fix text to match parameters
    Arguments:
    - `fileNames`: list of fileNames
    - `nGens`: Number of generations since admixture used in hmm filter (default=6)
    - `svmC`: missclassification penalty term in svm (default=100)
    - `win_size`: number of snps in each window (default=100)

    Returns:
    - `subjects`: list of subject names in admixed sample
    - `snpNames`: list of snpIds    
    - `snpLocations`: list of positions in bp
    - `admixedClassPre`: classification of admixed samples before hmm filter
    - `admixedClass`:    classification of admixed samples after hmm filter
    - `p`: posterior probability of ancestry assignments
    """
    files=fileReader.concurrentFileReader(*fileNames, key=1)
    snpNames=[]
    snpLocations=[]     #stores physical location from files
    ancestralSuccess=[] #stores success of ancestral classification
    admixedClass=[]     #stores classification of test Subjects
    classifier=regionClassifier.SVMpymvpa(C=svmC)
    smoother=regionClassifier.hmmFilter(geneticMapFile=MAPFILES%chrom,nGens=nGens,nClasses=len(fileNames)-1)

    subjects=files.next()[0]
    nTrain=np.sum(map(len, subjects[:-1]))  #Number of samples in training set
    nTest=len(subjects[-1]);
    labelsTrain =sum([[i]*len(sub) for i, sub in enumerate(subjects[:-1])],[])
    vals=np.zeros((nTrain+nTest, win_size))  #temporary storage of output
    while True: #for j in range(100): #To go through all positions in file
        for i, (snpInfo, snps) in enumerate(files):
            snpNames.append(snpInfo[0])
            snpLocations.append(float(snpInfo[1]))
            vals[:,i] = fileReader.nucleotides2Haplotypes(sum(snps, []))
            if i==vals.shape[1]-1:
                break
        ancestral, admixed=classifier(vals[:nTrain,:i+1], labelsTrain, vals[-nTest:, :i+1])
        ancestralSuccess.append(ancestral)
        admixedClass.append(admixed)
        if i<win_size-1:
            break
    admixedClassPre=np.array(admixedClass)
    admixedClass, p=smoother(snpLocations, ancestralSuccess, admixedClassPre)
    
    return subjects[-1], snpNames, snpLocations, admixedClassPre, admixedClass, p


def accuracySummary(correctFile, admixedFile):
    """If given a file with the correct classifications calculates the accuracy

    Arguments:
    - `correctFile`: File name of correct classifications
    - `admixedFile`: File name for admixed output
    """
    #correct=np.array([l.split()[2:] for l in fileReader.openfile(correctFile).readlines()[1:]], np.float)
    totalCorrect=0
    total=0
    for labels, ancestry in fileReader.concurrentFileReader(correctFile, admixedFile, 
                                                            key=[0,1], nHeaders=0, nLabels=4):
        data=zip(ancestry[0],ancestry[1])
        totalCorrect+=sum([a==b for a,b in data])
        total+=len(data)
    hmmSuccess=100.0*totalCorrect/total
    print 'Correct %0.3g' %(hmmSuccess)


def saveFiles(params, subjects, snpNames, snpLocations, admixedClass, p):
    """Saves two tped files and a tfam file of the ancestry classifications

    Arguments:
    - `params`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probabiltity for each classified loci
    """
    nSubs=admixedClass.shape[1]
    with open(params['saveFile']+".tfam","w") as tFamFp:
        pedPadding="0 %s 0 0 0 0 0"
        for subject in subjects:
            tFamFp.write("%s\n"%pedPadding%subject)
    tPedFp=open(params['saveFile']+".tped","w")
    tPedProbFp=open(params['saveFile']+".Probs.tped","w")
    for i, (rsId, rsPos) in enumerate(zip(snpNames, snpLocations)):
        tPedFp.write('%s %s 0 %i' %(params['chrom'], rsId, rsPos))
        tPedFp.write(' %i'*nSubs %tuple(admixedClass[i/params['win'], :]))
        tPedFp.write('\n')
        tPedProbFp.write('%s %s 0 %i' %(params['chrom'], rsId, rsPos))
        tPedProbFp.write(' %g'*nSubs %tuple(p[i/params['win'], :]))
        tPedProbFp.write('\n')
    tPedFp.close()
    tFamFp.close()


def plotResults(params, subjects, snpNames, snpLocations, admixedClass, p):
    """Generates graphics output    
    Arguments:
    - `params`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probability for each classified loci
    """
    nColors=len(params['fileNames'])-1
    if not params['rgb']:
        params['rgb']=[pylab.cm.jet(i/(nColors-1.)*256) for i in range(nColors)]
    if not params['labels']:
        params['labels']=[os.path.split(l)[-1] for l in params['fileNames'][:-1]]
    #Convert classifications to colors
    imColors=np.zeros((admixedClass.shape[1],admixedClass.shape[0],4))
    nWins, nSubs=admixedClass.shape
    for i in range(nWins):
        for j in range(nSubs):
            imColors[j,i,:]=params['rgb'][int(admixedClass[i,j])]
    #Plot classificiations
    pylab.figure()
    ax=pylab.axes([.13, .1, .7, .85])
    pylab.imshow(imColors, interpolation='nearest')
    pylab.axis('tight')
    pylab.yticks(range(len(subjects)), subjects)
    pylab.ylim(-.5, len(subjects)-.5)
    pos, labels=pylab.xticks()
    labels=np.round(np.asarray(snpLocations[::len(snpLocations)/(len(labels)-3)])/1e6)
    pylab.xticks(pos[1:-1], labels.astype(np.int))
    pylab.xlabel('Position [Mb]')
    pylab.ylabel('Subjects')
    pylab.title('chromsomes%s' %params['chrom'])
    pylab.axes([.85, .1, .13, .85])
    y=0
    for i, label in enumerate(params['labels']):
        pylab.scatter(0,y, s=40, c=params['rgb'][i], linewidth=0)
        pylab.text(0+.5, y, label, fontsize=8, verticalalignment='center')
        y+=1;
    pylab.axis([-0.5, 8, -.3, len(params['labels'])-.5])
    pylab.axis('off')
    pylab.show()


def validateColors(value):
    conv=pylab.mpl.colors.ColorConverter()
    try:
        values=[conv.to_rgba(c) for c in value.split(',')]
        return values
    except:
#---TODO:  Change the Error to another type of error or handle the missing color by setting a default 
        raise OptionValueError('color specification to %s incorrect' %"RGB")


def validateLabels(value):
    try: 
        labels=value.split(',')
        return labels
    except:
        raise OptionValueError('label specification to %s incorrect' %"labels")
    
def initializeOptionsParser():
    pass

if __name__ == '__main__':
    #Parameter Defaults
    rawConfiguration={}
    rawConfiguration['chrom']=0
    rawConfiguration['win']=100
    rawConfiguration['nGens']=6.0
    rawConfiguration['saveFile']='outSupportMix'
    rawConfiguration['correctFile']=None
    rawConfiguration['fileNames']=[]
    rawConfiguration['doPlot']=None
    rawConfiguration['labels']=None
    rawConfiguration['rgb']=None
    rawConfiguration['configFile']=None

    #Command Line parsing of parameters
    parser = OptionParser(usage=USAGE)
    parser.add_option('-c', '--chromosome', type='str', dest='chrom',
                      help='Chromsome being analysed (default guessed from file names)', metavar='N')
    parser.add_option('-w', '--window', type='int', dest='win',
                      help='Number of SNPs in each window (default 100)', metavar='N')
    parser.add_option('-g', '--generations', type='float', dest='nGens',
                      help='Number of generations since admixture used in hmm. (default 6)', metavar='N')
    parser.add_option('-s', '--save', type='str', dest='saveFile',
                      help='Destination file to save output (default outSupportMix)', metavar='file')
    parser.add_option('-a', '--ancestryFile', type='string', dest='correctFile',
                      help='FILE contains correct classifications in tab delimited format with SNPs in rows and samples in columns (first two columns contain rsID and position. ', metavar='FILE')
    parser.add_option('-C', '--config', type='string', dest='configFile',
                      help='Use a config file instead of parameters', metavar='file')
    group = OptionGroup(parser, 'Plotting Options', 'Use these options to generate graphics and customize graphics.'
                    'It is believed that some of them bite.')
    group.add_option('-p', '--plot', dest='doPlot', action='store_true',
                      help='Generate graphical output')
    group.add_option('--RGB', type='string',  dest='rgb', metavar='colors',
                      help='Color specifications of different populations for graphing : ')
    group.add_option('--labels', type='string', dest='labels', metavar='labels',
                      help='populations labels for graphing Example: ceu,yri,mkk')
    parser.add_option_group(group)
    (cmdOptions, args) = parser.parse_args()
    
    #Config file parsing
    if cmdOptions.configFile:
        if DEBUG:
            print "Running with options listed in:", os.path.abspath(cmdOptions.configFile)
        if os.path.exists(cmdOptions.configFile):
            configData=supportConfig.getConfigOptions(cmdOptions.configFile)
            for k,value in configData.iteritems():
                if value!=None:
                    rawConfiguration[k]=value
            #Added support for chromosome only and ancestry files on the config file
            #         Is this really a stupid idea?  Should we ship a default config file instead?
            if len(rawConfiguration['fileNames'])==1:  #no ancestral files given run in default with all HGDP populations
                admixed=rawConfiguration['fileNames']
                rawConfiguration['fileNames']=glob.glob(HGDP_BASENAME%rawConfiguration['chrom'])
                rawConfiguration['fileNames'].extend(admixed)
            elif len(rawConfiguration['fileNames'])==2:  #too few ancestral files given 
                supportConfig.fail(parser, 'Not enough ancestral populations were given')
        else:
            supportConfig.fail(parser, 'Invalid Config File Specified')
    else:
        #We only use the arguments if a config file is not specified
        #bellow we assume that cndOptions.chrom is set
        if len(args)==1:  #no ancestral files given run in default with all HGDP populations
            cmdOptions.fileNames=glob.glob(HGDP_BASENAME%cmdOptions.chrom)
            cmdOptions.fileNames.extend(args)
        elif len(args)==2:  #too few ancestral files given 
            supportConfig.fail(parser, 'Not enough ancestral populations were given')
        else:
            cmdOptions.fileNames=args
                
    #Overwrite the "raw" configuration values with command line values whenever
    for key,value in cmdOptions.__dict__.iteritems():
        if value!=None:
            rawConfiguration[key]=value
    #keep the original parameters
    params=rawConfiguration.copy()
 
    if params['rgb']!=None:
        params['rgb']=validateColors(params['rgb'])
        params['doPlot']=True
        #make life easier to save the values here
        rawConfiguration['doPlot']=True
    if params['labels']!=None:
        params['labels']=validateLabels(params['labels'])
        params['doPlot']=True
        rawConfiguration['doPlot']=True       
    if params['rgb']!=None and len(params['rgb'])<len(params['fileNames'])-1:
        supportConfig.fail(parser, 'too few colors specified to --RGB')
    if params['labels']!=None and len(params['labels'])<len(params['fileNames'])-1:
        supportConfig.fail(parser, 'too few labels specified to --labels')
    if params['chrom']==0: #Use filenames to guess the chromsome used
        params['chrom']=determineChromosome(params['fileNames']).replace('chr','')
        sys.stderr.write('WARNING! No chromosome was specified assuming: %s\n'%params['chrom'])
    
    if DEBUG:
        print "CmdLine Options Parameters",params
        print "Running SVM with the following options",params['fileNames'], params['nGens'], params['win'], params['chrom']
    
    subs, snpNames, snpLocs, admixedClassPre, admixedClass,p = runSVM(params['fileNames'], params['nGens'], 
                                                                      params['win'], params['chrom'])
    
    saveFiles(params, subs, snpNames, snpLocs, admixedClass, p)
    #output results
    for i, pop in enumerate(params['fileNames'][:-1]):
        pop=os.path.split(pop)[-1]
        sys.stdout.write('Pop %s: %2.2g%%\n' %(pop, 100*np.sum(admixedClass.flatten()==i)/float(np.prod(admixedClass.shape))))
    bp, gm=winSizeBPandCM(snpLocs, params['win'], params['chrom'])
    sys.stdout.write('Mean window size: %i+/-%i bp, %2.2g+/-%2.2g cM\n' %(bp.mean(), bp.std(), gm.mean(), gm.std()))
    if params['correctFile']:accuracySummary(params['correctFile'], params['saveFile']+".tped")
    if params['doPlot']: plotResults(params, subs, snpNames, snpLocs, admixedClass, p)
    supportConfig.writeConfigFile(rawConfiguration,params['saveFile']+'.cfg')
