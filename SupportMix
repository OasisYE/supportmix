#!/usr/bin/python
DEBUG=False
import sys
import gzip
import glob
import os
import pylab, matplotlib
import numpy as np
from optparse import OptionParser, OptionGroup, OptionValueError

import fileReader
import regionClassifier
import supportConfig

### TRYING SCIPY COMPILE WORKAROUND
#---  SCIPY cxFreeze dependency fixes
import scipy.misc
import scipy
scipy.factorial = scipy.misc.common.factorial

from scipy import factorial
import scipy.signal

#---  matplotlib cxFreeze dependency fixes
import matplotlib.backends.backend_tkagg
####################################

HGDP_BASENAME=supportConfig.createDataPath('data/hgdp/*/*chr%s.bgl.phased.gz')
MAPFILES=supportConfig.createDataPath('data/hapmap2/genetic_map_chr%s_b36.txt')
#USAGE="""%prog [options] ancestralFile1 ancestralFile2 [...] admixedFile
#
#where the ancestralFiles and admixedFiles are contain phased samples
#in tab delimited format snps in rows and samples in columns.  One row
#of column headers and two columns of header information (i.e. rsId and
#position).  The files have to be from the same chromosome indicated by
#including chr[0-9]* in the name.
#"""


def winSizeBPandCM(snpLocations, winSize, chrom):
    gm=regionClassifier.geneticMap(MAPFILES%chrom)
    winStarts=[0]; winStarts.extend(snpLocations[::winSize])
    gmPos=gm.pos2gm(winStarts)
    return np.diff(winStarts), np.diff(gmPos)


def determineChromosome(fileNames):
    """Estimates the chromosome name by searching for "chr" in input
    file names.
    Arguments:
    - @fileNames:List of fileNames 
    """
    import re 
    p = re.compile('chr\d*', re.IGNORECASE)
    try:
        found=[p.search(name).group() for name in fileNames]
        if not np.all(found[0]==np.asarray(found)): raise Error
        return found[0]
    except:
        supportConfig.fail(parser, 'If no chromosome is specified then all fileNames must contain the same pattern of: chr[0-9]*')

def openFiles(params):
    """Open files and return return concurrentFileReader object along with subjects.
    Handles the possibility of both tped files and tfam files

    Arguments:
    - `params`: dictionary of settings
    Returns:
    - `subjects` - list of list of subjects
    - `files` - concurrentFileReader object
    """
    files=params['fileNames']
    if params['isBeagle']:
        files=fileReader.concurrentFileReader(*files, nHeaders=1, key=1, nLabels=2)
        subjects=files.next()[0]
        return subjects, files
    else:
        tfams=[f.replace('.tped', '.tfam') for f in files]
        tfams=[fileReader.openfile(f) for f in tfams]
        subjects=[]
        for f in tfams:
            subs=[[l.split(None, 1)[0]+'_b',l.split(None, 1)[0]+'_b']  for l in f]
            subjects.append(np.asarray(sum(subs, [])))
        files=fileReader.concurrentFileReader(*files, nHeaders=0, key=[0,1], nLabels=4)
        return subjects, files


def runSVM(params,  svmC=100):
    """Deconvolves ancestry in last file based on ancestral
    populations in first files. TODO fix text to match parameters
    Arguments:
    - `params`: dictionary with at least variables for fileNames, nGens, win and chrom
    - `svmC`: slack variable for SVM (default=100)
    Returns:
    - `subjects`: list of subject names in admixed sample
    - `snpNames`: list of snpIds    
    - `snpLocations`: list of positions in bp
    - `admixedClassPre`: classification of admixed samples before hmm filter
    - `admixedClass`:    classification of admixed samples after hmm filter
    - `p`: posterior probability of ancestry assignments
    """
    nGens=params['nGens']
    winSize=params['win']
    chrom=params['chrom']
    mapFile=MAPFILES%chrom #TODO fix to reference given file
    if DEBUG:
        print "Running SVM With:",params

    snpNames=[]
    snpLocations=[]     #stores physical location from files
    snpGeneticMap=[]     #stores physical location from files
    ancestralSuccess=[] #stores success of ancestral classification
    admixedClass=[]     #stores classification of test Subjects
    subjects, files=openFiles(params)

    classifier=regionClassifier.SVMpymvpa(C=svmC)
    smoother=regionClassifier.hmmFilter(geneticMapFile=mapFile,nGens=nGens,nClasses=len(subjects)-1)

    nTrain=np.sum(map(len, subjects[:-1]))  #Number of samples in training set
    nTest=len(subjects[-1]);
    labelsTrain =sum([[i]*len(sub) for i, sub in enumerate(subjects[:-1])],[])
    print map(len, subjects)
    vals=np.zeros((nTrain+nTest, winSize))  #temporary storage of output
    while True: 
        for i, (snpInfo, snps) in enumerate(files):
            if params['isBeagle']:
                snpNames.append(snpInfo[0])
                snpLocations.append(float(snpInfo[1]))
            else:
                if snpInfo[0]!=chrom: break  #TODO does not work because we are still classifying
                snpNames.append(snpInfo[1])
                snpLocations.append(float(snpInfo[3]))
                #TODO check that we are looking at the right chromsome
            vals[:,i] = fileReader.nucleotides2Haplotypes(sum(snps, []))
            if i==vals.shape[1]-1:
                break
        ancestral, admixed=classifier(vals[:nTrain,:i+1], labelsTrain, vals[-nTest:, :i+1])
        ancestralSuccess.append(ancestral)
        admixedClass.append(admixed)
        if i<winSize-1:
            break
    admixedClassPre=np.array(admixedClass)
    admixedClass, p=smoother(snpLocations, ancestralSuccess, admixedClassPre)
    return subjects[-1], snpNames, snpLocations, admixedClassPre, admixedClass, p


def accuracySummary(correctFile, admixedFile):
    """If given a file with the correct classifications calculates the accuracy

    Arguments:
    - `correctFile`: File name of correct classifications
    - `admixedFile`: File name for admixed output
    """
    totalCorrect=0
    total=0
    for labels, ancestry in fileReader.concurrentFileReader(correctFile, admixedFile, 
                                                            key=[0,1], nHeaders=0, nLabels=4):
        data=zip(ancestry[0],ancestry[1])
        totalCorrect+=sum([a==b for a,b in data])
        total+=len(data)
    hmmSuccess=100.0*totalCorrect/total
    print 'Correct %0.3g' %(hmmSuccess)


def saveFiles(params, subjects, snpNames, snpLocations, admixedClass, p):
    """Saves two tped files and a tfam file of the ancestry classifications

    Arguments:
    - `params`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probabiltity for each classified loci
    """
    nSubs=admixedClass.shape[1]
    with open(params['saveFile']+".tfam","w") as tFamFp:
        pedPadding="0 %s 0 0 0 0 0"
        for subject in subjects:
            tFamFp.write("%s\n"%pedPadding%subject)
    tPedFp=open(params['saveFile']+".tped","w")
    tPedProbFp=open(params['saveFile']+".Probs.tped","w")
    for i, (rsId, rsPos) in enumerate(zip(snpNames, snpLocations)):
        tPedFp.write('%s %s 0 %i' %(params['chrom'], rsId, rsPos))
        tPedFp.write(' %i'*nSubs %tuple(admixedClass[i/params['win'], :]))
        tPedFp.write('\n')
        tPedProbFp.write('%s %s 0 %i' %(params['chrom'], rsId, rsPos))
        tPedProbFp.write(' %g'*nSubs %tuple(p[i/params['win'], :]))
        tPedProbFp.write('\n')
    tPedFp.close()
    tFamFp.close()


def plotResults(params, subjects, snpNames, snpLocations, admixedClass, p):
    """Generates graphics output    
    Arguments:
    - `params`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probability for each classified loci
    """
    nColors=len(params['fileNames'])-1
    if not params['rgb']:
        params['rgb']=[pylab.cm.jet(i/(nColors-1.)*256) for i in range(nColors)]
    if not params['labels']:
        params['labels']=[os.path.split(l)[-1] for l in params['fileNames'][:-1]]
    #Convert classifications to colors
    imColors=np.zeros((admixedClass.shape[1],admixedClass.shape[0],4))
    nWins, nSubs=admixedClass.shape
    for i in range(nWins):
        for j in range(nSubs):
            imColors[j,i,:]=params['rgb'][int(admixedClass[i,j])]
    #Plot classificiations
    pylab.figure()
    ax=pylab.axes([.13, .1, .7, .85])
    pylab.imshow(imColors, interpolation='nearest')
    pylab.axis('tight')
    pylab.yticks(range(len(subjects)), subjects)
    pylab.ylim(-.5, len(subjects)-.5)
    pos, labels=pylab.xticks()
    labels=np.round(np.asarray(snpLocations[::len(snpLocations)/(len(labels)-3)])/1e6)
    pylab.xticks(pos[1:-1], labels.astype(np.int))
    pylab.xlabel('Position [Mb]')
    pylab.ylabel('Subjects')
    pylab.title('chromsomes%s' %params['chrom'])
    pylab.axes([.85, .1, .13, .85])
    y=0
    for i, label in enumerate(params['labels']):
        pylab.scatter(0,y, s=40, c=params['rgb'][i], linewidth=0)
        pylab.text(0+.5, y, label, fontsize=8, verticalalignment='center')
        y+=1;
    pylab.axis([-0.5, 8, -.3, len(params['labels'])-.5])
    pylab.axis('off')
    pylab.show()



if __name__ == '__main__':
    #Set Parameter Defaults
    supportConfig.CHROM=0
    supportConfig.WIN=100
    supportConfig.N_GENS=6.0
    supportConfig.SAVE_FILE='outSupportMix'
    supportConfig.CORRECT_FILE=None
    supportConfig.FILE_NAMES=[]

    supportConfig.DO_PLOT=None
    supportConfig.RGB=None
    supportConfig.CONFIGFILE=None
    supportConfig.LABELS=None
    supportConfig.IS_BEAGLE=None
    supportConfig.MAP_DIR=None
    supportConfig.N_PARALLEL=None

#   
    rawConfiguration={}
    params=supportConfig.getParameters(rawConfiguration)
 
    if len(params['fileNames'])<3:
        supportConfig.fail(parser, 'Not enough ancestral populations were given')

    if DEBUG:
        print "CmdLine Options Parameters",params
        print "Running SVM with the following options",params['fileNames'], params['nGens'], params['win'], params['chrom']
    
    subs, snpNames, snpLocs, admixedClassPre, admixedClass,p = runSVM(params)
    
    saveFiles(params, subs, snpNames, snpLocs, admixedClass, p)
    #output results
    for i, pop in enumerate(params['fileNames'][:-1]):
        pop=os.path.split(pop)[-1]
        sys.stdout.write('Pop %s: %2.2g%%\n' %(pop, 100*np.sum(admixedClass.flatten()==i)/float(np.prod(admixedClass.shape))))
    bp, gm=winSizeBPandCM(snpLocs, params['win'], params['chrom'])
    sys.stdout.write('Mean window size: %i+/-%i bp, %2.2g+/-%2.2g cM\n' %(bp.mean(), bp.std(), gm.mean(), gm.std()))
    if params['correctFile']:accuracySummary(params['correctFile'], params['saveFile']+".tped")
    if params['doPlot']: plotResults(params, subs, snpNames, snpLocs, admixedClass, p)
    supportConfig.writeConfigFile(rawConfiguration,params['saveFile']+'.cfg')
