#!/usr/bin/python
DEBUG=False
import sys
import gzip
import glob
import os
import pylab, matplotlib
import numpy as np
from optparse import OptionParser, OptionGroup, OptionValueError

import fileReader
import regionClassifier
import supportConfig

### TRYING SCIPY COMPILE WORKAROUND
#---  SCIPY cxFreeze dependency fixes
import scipy.misc
import scipy
scipy.factorial = scipy.misc.common.factorial

from scipy import factorial
import scipy.signal

#---  matplotlib cxFreeze dependency fixes
import matplotlib.backends.backend_tkagg
####################################

HGDP_BASENAME=supportConfig.createDataPath('data/hgdp/*/*%s.bgl.phased.gz')
MAPFILES=supportConfig.createDataPath('data/hapmap2/genetic_map_%s_b36.txt')
USAGE="""%prog [options] ancestralFile1 ancestralFile2 [...] admixedFile

where the ancestralFiles and admixedFiles are contain phased samples
in tab delimited format snps in rows and samples in columns.  One row
of column headers and two columns of header information (i.e. rsId and
position).  The files have to be from the same chromosome indicated by
including chr[0-9]* in the name.
"""


def winSizeBPandCM(snpLocations, winSize, chrom):
    gm=regionClassifier.geneticMap(MAPFILES%chrom)
    winStarts=[0]; winStarts.extend(snpLocations[::winSize])
    gmPos=gm.pos2gm(winStarts)
    return np.diff(winStarts), np.diff(gmPos)


def determineChromosome(fileNames):
    """Estimates the chromosome name by searching for "chr" in input
    file names.
    Arguments:
    - @fileNames:List of fileNames 
    """
    import re 
    p = re.compile('chr\d*', re.IGNORECASE)
    try:
        found=[p.search(name).group() for name in fileNames]
        if not np.all(found[0]==np.asarray(found)): raise Error
        return found[0]
    except:
        print "ERROR: names of input files should contain the same chr[0-9]*"
        sys.exit()


def runSVM(fileNames, nGens, win_size, chrom, svmC=100):
    """Deconvolves ancestry in last file based on ancestral
    populations in first files. TODO fix text to match parameters
    Arguments:
    - `fileNames`: list of fileNames
    - `nGens`: Number of generations since admixture used in hmm filter (default=6)
    - `svmC`: missclassification penalty term in svm (default=100)
    - `win_size`: number of snps in each window (default=100)

    Returns:
    - `subjects`: list of subject names in admixed sample
    - `snpNames`: list of snpIds    
    - `snpLocations`: list of positions in bp
    - `admixedClassPre`: classification of admixed samples before hmm filter
    - `admixedClass`:    classification of admixed samples after hmm filter
    - `p`: posterior probability of ancestry assignments
    """
    files=fileReader.concurrentFileReader(*fileNames, key=1)
    snpNames=[]
    snpLocations=[]     #stores physical location from files
    ancestralSuccess=[] #stores success of ancestral classification
    admixedClass=[]     #stores classification of test Subjects
    classifier=regionClassifier.SVMpymvpa(C=svmC)
    smoother=regionClassifier.hmmFilter(geneticMapFile=MAPFILES%chrom,nGens=nGens,nClasses=len(fileNames)-1)

    subjects=files.next()[0]
    nTrain=np.sum(map(len, subjects[:-1]))  #Number of samples in training set
    nTest=len(subjects[-1]);
    labelsTrain =sum([[i]*len(sub) for i, sub in enumerate(subjects[:-1])],[])
    vals=np.zeros((nTrain+nTest, win_size))  #temporary storage of output
    while True: #for j in range(100): #To go through all positions in file
        for i, (snpInfo, snps) in enumerate(files):
            snpNames.append(snpInfo[0])
            snpLocations.append(float(snpInfo[1]))
            vals[:,i] = fileReader.nucleotides2Haplotypes(sum(snps, []))
            if i==vals.shape[1]-1:
                break
        ancestral, admixed=classifier(vals[:nTrain,:i+1], labelsTrain, vals[-nTest:, :i+1])
        ancestralSuccess.append(ancestral)
        admixedClass.append(admixed)
        if i<win_size-1:
            break
    admixedClassPre=np.array(admixedClass)
    admixedClass, p=smoother(snpLocations, ancestralSuccess, admixedClassPre)
    
    return subjects[-1], snpNames, snpLocations, admixedClassPre, admixedClass, p


def accuracySummary(correctFile, admixedFile):
    """If given a file with the correct classifications calculates the accuracy

    Arguments:
    - `correctFile`: File name of correct classifications
    - `admixedFile`: File name for admixed output
    """
    #correct=np.array([l.split()[2:] for l in fileReader.openfile(correctFile).readlines()[1:]], np.float)
    totalCorrect=0
    total=0
    for labels, ancestry in fileReader.concurrentFileReader(correctFile, admixedFile, 
                                                            key=[0,1], nHeaders=0, nLabels=4):
        data=zip(ancestry[0],ancestry[1])
        totalCorrect+=sum([a==b for a,b in data])
        total+=len(data)
    hmmSuccess=100.0*totalCorrect/total
    print 'Correct %0.3g' %(hmmSuccess)


def saveFiles(options, subjects, snpNames, snpLocations, admixedClass, p):
    """Saves two tped files and a tfam file of the ancestry classifications

    Arguments:
    - `options`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probabiltity for each classified loci
    """
    nSubs=admixedClass.shape[1]
    with open(options.saveFile+".tfam","w") as tFamFp:
        pedPadding="0 %s 0 0 0 0 0"
        for subject in subjects:
            tFamFp.write("%s\n"%pedPadding%subject)
    tPedFp=open(options.saveFile+".tped","w")
    tPedProbFp=open(options.saveFile+".Probs.tped","w")
    for i, (rsId, rsPos) in enumerate(zip(snpNames, snpLocations)):
        tPedFp.write('%s %s 0 %i' %(options.chrom, rsId, rsPos))
        tPedFp.write(' %i'*nSubs %tuple(admixedClass[i/options.win, :]))
        tPedFp.write('\n')
        tPedProbFp.write('%s %s 0 %i' %(options.chrom, rsId, rsPos))
        tPedProbFp.write(' %g'*nSubs %tuple(p[i/options.win, :]))
        tPedProbFp.write('\n')
    tPedFp.close()
    tFamFp.close()


def plotResults(options, subjects, snpNames, snpLocations, admixedClass, p):
    """Generates graphics output    
    Arguments:
    - `options`: contains the options used to run the sample
    - `subjects`:list of subjects
    - `snpNames`:list of rsIds
    - `snpLocations`: list of positions of rsIds
    - `admixedClass`: matrix of classifications
    - `p`: matrix of posterior probabiltity for each classified loci
    """
    nColors=len(options.fileNames)-1
    if not options.rgb:
        options.rgb=[pylab.cm.jet(i/(nColors-1.)*256) for i in range(nColors)]
    if not options.labels:
        options.labels=[os.path.split(l)[-1] for l in options.fileNames[:-1]]
    #Convert classifications to colors
    imColors=np.zeros((admixedClass.shape[1],admixedClass.shape[0],4))
    nWins, nSubs=admixedClass.shape
    for i in range(nWins):
        for j in range(nSubs):
            imColors[j,i,:]=options.rgb[int(admixedClass[i,j])]
    #Plot classificiations
    pylab.figure()
    ax=pylab.axes([.13, .1, .7, .85])
    pylab.imshow(imColors, interpolation='nearest')
    pylab.axis('tight')
    pylab.yticks(range(len(subjects)), subjects)
    pylab.ylim(-.5, len(subjects)-.5)
    pos, labels=pylab.xticks()
    labels=np.round(np.asarray(snpLocations[::len(snpLocations)/(len(labels)-3)])/1e6)
    pylab.xticks(pos[1:-1], labels.astype(np.int))
    pylab.xlabel('Position [Mb]')
    pylab.ylabel('Subjects')
    pylab.title(options.chrom)
    pylab.axes([.85, .1, .13, .85])
    y=0
    for i, label in enumerate(options.labels):
        pylab.scatter(0,y, s=40, c=options.rgb[i], linewidth=0)
        pylab.text(0+.5, y, label, fontsize=8, verticalalignment='center')
        y+=1;
    pylab.axis([-0.5, 8, -.3, len(options.labels)-.5])
    pylab.axis('off')
    pylab.show()

def optColorProcessor(option, opt_str, value, parser):
    conv=pylab.mpl.colors.ColorConverter()
    try: 
        parser.values.rgb=[conv.to_rgba(c) for c in value.split(',')]
        parser.values.doPlot=True
    except:
        raise OptionValueError('color specification to %s incorrect' %opt_str)


def validateColors(value):
    conv=pylab.mpl.colors.ColorConverter()
    values=[conv.to_rgba(c) for c in value.split(',')]
    return values
#    except:
#        raise OptionValueError('color specification to %s incorrect' %"RGB")


def optLabelProcessor(option, opt_str, value, parser):
    try: 
        parser.values.labels=value.split(',')
        parser.values.doPlot=True
    except:
        raise OptionValueError('label specification to %s incorrect' %opt_str)

#def optConfigFileProcessor(option, opt_str, value, parser):
#    print "Calling Processor"
#    print "Running with options listed in:", os.path.abspath(value)
#    #print "Values",parser.values
#    configData=supportConfig.getConfigOptions(value)
#    #for key in configData:
#    #    parser.values[key]=configData[key]
#    #print "New Values",parser.values
#    parser.values.chrom=configData['chrom']
#    parser.values.win=configData['win']
#    parser.values.nGens=configData['nGens']
#    parser.values.saveFile=configData['saveFile']
#    parser.values.correctFile=configData['correctFile']
#    parser.values.fileNames=configData['fileNames']
#    parser.values.doPlot=configData['doPlot']
#    
#    if configData['labels']:
#        parser.values.labels=configData['labels'].split(',')
#        
#    if configData['RGB']:
#        parser.values.rgb=validateColors(configData['RGB'])
    

if __name__ == '__main__':
    parser = OptionParser(usage=USAGE)
    parser.add_option('-c', '--chromosome', type='int', dest='chrom', default=0,
                      help='Chromsome being analysed (default guessed from file names)', metavar='N')
    parser.add_option('-w', '--window', type='int', dest='win', default=100,
                      help='Number of SNPs in each window (default 100)', metavar='N')
    parser.add_option('-g', '--generations', type='float', dest='nGens', default=6,
                      help='Number of generations since admixture used in hmm. (default 6)', metavar='N')
    parser.add_option('-s', '--save', type='str', dest='saveFile', default='outSupportMix',
                      help='Destination file to save output (default outSupportMix)', metavar='file')
    parser.add_option('-a', '--ancestryFile', type='string', dest='correctFile',
                      help='FILE contains correct classifications in tab delimited format with SNPs in rows and samples in columns (first two columns contain rsID and position. ', metavar='FILE')
    parser.add_option('-C', '--config', type='string', dest='configFile',
                      help='Use a config file instead of parameters', metavar='file')
#    parser.add_option('-C', '--config', type='string', dest='configFile', action='callback', callback=optConfigFileProcessor,
#                      help='Use a config file instead of parameters', metavar='file')
    group = OptionGroup(parser, 'Plotting Options', 'Use these options to generate graphics and customize graphics.'
                    'It is believed that some of them bite.')
    group.add_option('-p', '--plot', dest='doPlot', action='store_true', default=False,
                      help='Generate graphical output')
    group.add_option('--RGB', type='string',  dest='rgb', action='callback', callback=optColorProcessor, 
                      help='Color specifications of different populations for graphing : ', metavar='colors')
    group.add_option('--labels', type='string', dest='labels', action='callback', callback=optLabelProcessor,
                      help='populations labels for graphing Example: ceu,yri,mkk', metavar='labels')
    parser.add_option_group(group)
    (options, args) = parser.parse_args()
    
    
    if len(args)==1:  #no ancestral files given run in default with all HGDP populations
        options.fileNames=glob.glob(HGDP_BASENAME%options.chrom)
        options.fileNames.extend(args)
    else: options.fileNames=args
    
    if options.configFile:
        
        print "Running with options listed in:", os.path.abspath(options.configFile)
        #print "Values",parser.values
        if os.path.exists(options.configFile):
            configData=supportConfig.getConfigOptions(options.configFile)
            #for key in configData:
            #    parser.values[key]=configData[key]
            #print "New Values",parser.values
            #options.chrom=configData['chrom'] if options.chrom==0 else options.chrom
            
            options.chrom=configData['chrom']
            
            options.win=configData['win']
            #options.win=configData['win'] if options.win==100 else options.win 
            options.nGens=configData['nGens']
            options.saveFile=configData['saveFile']
            options.correctFile=configData['correctFile']
            options.fileNames=configData['fileNames']
            
            if not options.doPlot: 
                #Check if plot was set before
                options.doPlot=configData['doPlot']
                
                if configData['labels']:
                    options.labels=configData['labels'].split(',')
                    
                if configData['RGB']:
                    options.rgb=validateColors(configData['RGB'])
        else:
            #just print the error here. Correct error handling should be specified
            print "Error Invalid Config File Specified"
                
        #print supportConfig.getConfigOptions("SupportConfig.cfg")
        
    if options.rgb!=None and len(options.rgb)<len(args)-1:
        parser.print_usage()
        sys.stderr.write('SupportMix: error: too few colors specified to --RGB\n')
        sys.exit()
    if options.labels!=None and len(options.labels)<len(args)-1:
        parser.print_usage
        sys.stderr.write('SupportMix: error: too few colors specified to --RGB\n')
        sys.exit()

    if options.chrom==0: #Use filenames to guess the chromsome used
        options.chrom=determineChromosome(args)
        sys.stderr.write('WARNING! No chromosome was specified assuming: %s\n'%options.chrom)
    else:
        options.chrom='chr%s'%options.chrom
#    if len(args)==1:  #no ancestral files given run in default with all HGDP populations
#        options.fileNames=glob.glob(HGDP_BASENAME%options.chrom)
#        options.fileNames.extend(args)
#    else: options.fileNames=args

    if DEBUG:
        print "Running SVM with the following options",options.fileNames, options.nGens,options.win, options.chrom

    subs, snpNames, snpLocs, admixedClassPre, admixedClass,p = runSVM(options.fileNames, options.nGens, 
                                                                      options.win, options.chrom)
    saveFiles(options, subs, snpNames, snpLocs, admixedClass, p)
    #output results
    for i, pop in enumerate(options.fileNames[:-1]):
        pop=os.path.split(pop)[-1]
        print 'Pop %s: %2.2g' %(pop, 100*np.sum(admixedClass.flatten()==i)/float(np.prod(admixedClass.shape)))
    if options.correctFile: accuracySummary(options.correctFile, options.saveFile+".tped")
    bp, gm=winSizeBPandCM(snpLocs, options.win, options.chrom)
    print 'Mean window size: %i+/-%i bp, %2.2g+/-%2.2g cM' %(bp.mean(), bp.std(), gm.mean(), gm.std())
    if options.doPlot: plotResults(options, subs, snpNames, snpLocs, admixedClass, p)
